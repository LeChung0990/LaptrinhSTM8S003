#include "stm8s.h"
#include "mylibrary.h"

#define I2C_CLOCK		100000
#define OLED_I2C_ADDR	0x78
#define OLED_CMD_MODE   0x00	// set command mode
#define OLED_DAT_MODE   0x40    // set data mode

const uint8_t OLED_INIT_CMD[] = {
	0xA8, 0x1F,       // set multiplex (HEIGHT-1): 0x1F for 128x32, 0x3F for 128x64
	0xD3, 0x00, 0x03, // set min and max page
	0x20, 0x00,       // set horizontal memory addressing mode
	0xDA, 0x12,       // set COM pins hardware configuration to sequential
	0x8D, 0x10,       // enable charge pump
	0xAF,             // switch on OLED
	0xA1, 0xC8        // flip the screen
};
// standard ASCII 5x8 font (adapted from Neven Boyanov and Stephen Denne)
const uint8_t OLED_FONT[]= {
	0x00, 0x00, 0x00, 0x00, 0x00, //   0
	0x00, 0x00, 0x2f, 0x00, 0x00, // ! 1
	0x00, 0x07, 0x00, 0x07, 0x00, // " 2
	0x14, 0x7f, 0x14, 0x7f, 0x14, // # 3
	0x24, 0x2a, 0x7f, 0x2a, 0x12, // $ 4
	0x62, 0x64, 0x08, 0x13, 0x23, // % 5
	0x36, 0x49, 0x55, 0x22, 0x50, // & 6
	0x00, 0x05, 0x03, 0x00, 0x00, // ' 7
	0x00, 0x1c, 0x22, 0x41, 0x00, // ( 8
	0x00, 0x41, 0x22, 0x1c, 0x00, // ) 9
	0x14, 0x08, 0x3E, 0x08, 0x14, // * 10
	0x08, 0x08, 0x3E, 0x08, 0x08, // + 11
	0x00, 0x00, 0xA0, 0x60, 0x00, // , 12
	0x08, 0x08, 0x08, 0x08, 0x08, // - 13
	0x00, 0x60, 0x60, 0x00, 0x00, // . 14
	0x20, 0x10, 0x08, 0x04, 0x02, // / 15
	0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 16
	0x00, 0x42, 0x7F, 0x40, 0x00, // 1 17
	0x42, 0x61, 0x51, 0x49, 0x46, // 2 18
	0x21, 0x41, 0x45, 0x4B, 0x31, // 3 19
	0x18, 0x14, 0x12, 0x7F, 0x10, // 4 20
	0x27, 0x45, 0x45, 0x45, 0x39, // 5 21
	0x3C, 0x4A, 0x49, 0x49, 0x30, // 6 22
	0x01, 0x71, 0x09, 0x05, 0x03, // 7 23
	0x36, 0x49, 0x49, 0x49, 0x36, // 8 24
	0x06, 0x49, 0x49, 0x29, 0x1E, // 9 25
	0x00, 0x36, 0x36, 0x00, 0x00, // : 26
	0x00, 0x56, 0x36, 0x00, 0x00, // ; 27
	0x08, 0x14, 0x22, 0x41, 0x00, // < 28
	0x14, 0x14, 0x14, 0x14, 0x14, // = 29
	0x00, 0x41, 0x22, 0x14, 0x08, // > 30
	0x02, 0x01, 0x51, 0x09, 0x06, // ? 31
	0x32, 0x49, 0x59, 0x51, 0x3E, // @ 32
	0x7C, 0x12, 0x11, 0x12, 0x7C, // A 33
	0x7F, 0x49, 0x49, 0x49, 0x36, // B 34
	0x3E, 0x41, 0x41, 0x41, 0x22, // C 35
	0x7F, 0x41, 0x41, 0x22, 0x1C, // D 36
	0x7F, 0x49, 0x49, 0x49, 0x41, // E 37
	0x7F, 0x09, 0x09, 0x09, 0x01, // F 38
	0x3E, 0x41, 0x49, 0x49, 0x7A, // G 39
	0x7F, 0x08, 0x08, 0x08, 0x7F, // H 40
	0x00, 0x41, 0x7F, 0x41, 0x00, // I 41
	0x20, 0x40, 0x41, 0x3F, 0x01, // J 42
	0x7F, 0x08, 0x14, 0x22, 0x41, // K 43
	0x7F, 0x40, 0x40, 0x40, 0x40, // L 44
	0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 45
	0x7F, 0x04, 0x08, 0x10, 0x7F, // N 46
	0x3E, 0x41, 0x41, 0x41, 0x3E, // O 47
	0x7F, 0x09, 0x09, 0x09, 0x06, // P 48
	0x3E, 0x41, 0x51, 0x21, 0x5E, // Q 49
	0x7F, 0x09, 0x19, 0x29, 0x46, // R 50
	0x46, 0x49, 0x49, 0x49, 0x31, // S 51
	0x01, 0x01, 0x7F, 0x01, 0x01, // T 52
	0x3F, 0x40, 0x40, 0x40, 0x3F, // U 53
	0x1F, 0x20, 0x40, 0x20, 0x1F, // V 54
	0x3F, 0x40, 0x38, 0x40, 0x3F, // W 55
	0x63, 0x14, 0x08, 0x14, 0x63, // X 56
	0x07, 0x08, 0x70, 0x08, 0x07, // Y 57
	0x61, 0x51, 0x49, 0x45, 0x43, // Z 58
	0x00, 0x7F, 0x41, 0x41, 0x00, // [ 59
	0x02, 0x04, 0x08, 0x10, 0x20, // \ 60
	0x00, 0x41, 0x41, 0x7F, 0x00, // ] 61
	0x04, 0x02, 0x01, 0x02, 0x04, // ^ 62
	0x40, 0x40, 0x40, 0x40, 0x40  // _ 63
};
uint8_t dem = 0;
uint8_t nut = 0;
uint16_t i = 0;
uint8_t ketqua = 0;

void nutnhan(void);
void OLED_init(void);
void OLED_printOneNumber(uint8_t num);
void OLED_printNumber(uint16_t ch);
void OLED_printP(const char *p);
void OLED_cursor(uint8_t xpos, uint8_t ypos);
void OLED_clear(void);

char a[] = "CHUNG";
void main (void)
{
    CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);
	GPIO_DeInit(GPIOB);
	GPIO_Init(GPIOB, GPIO_PIN_4, GPIO_MODE_OUT_OD_HIZ_SLOW);
	GPIO_Init(GPIOB, GPIO_PIN_5, GPIO_MODE_OUT_OD_HIZ_SLOW);

	I2C_init(I2C_CLOCK, OLED_I2C_ADDR);
	delay_msSetup();
	OLED_init();
    /*Mot nut nhan noi voi chan D2*/
    // GPIO_Init(GPIOD, GPIO_PIN_2, GPIO_MODE_IN_PU_IT);
    
	/*ngat ngoai tai chan D4, ngat tai canh xuong.
	ngo ra mach loc thong thap noi voi chan ngat*/
    // EXTI_DeInit();
    // GPIO_Init(GPIOD, GPIO_PIN_4, GPIO_MODE_IN_PU_IT);
    // EXTI_SetExtIntSensitivity(EXTI_PORT_GPIOD, EXTI_SENSITIVITY_FALL_ONLY);

	/*Thiet lap ngat cho timer4*/
	// TIM4_DeInit();
    // TIM4_TimeBaseInit(TIM4_PRESCALER_128, 125 - 1);
    // TIM4_SetCounter(0);
    // TIM4_ClearFlag(TIM4_FLAG_UPDATE);
    // TIM4_ITConfig(TIM4_IT_UPDATE, ENABLE);
	// disableInterrupts();
	// TIM4_Cmd(ENABLE);

	OLED_cursor(0,0);
	OLED_printP(a);
	OLED_cursor(0,2);
	OLED_printP(a);
	delay_ms(10);
	OLED_clear();
    while(1) 
    {
		OLED_cursor(0,0);
		OLED_printP(a);
		delay_ms(1000);
		OLED_clear();
		// nutnhan();
		// if(nut == 0)
		// {
			// OLED_cursor(100,3);
			// OLED_printP("COM!");
			// OLED_cursor(70,2);
			// OLED_printNumber(ketqua);
			
		// }
		// else 
		// {
		// 	OLED_cursor(100,3);
		// 	OLED_printP("RUN!");
		// }
    }
}
/*---------Ngat ngoai tai chan PD4----------*/
// INTERRUPT_HANDLER(EXTI_PORTD_IRQHandler, 6)
// {
//     dem++;
// }
/*----------------Ngat timer4------------*/
//  INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 23)
//  {
// 	TIM4_SetCounter(0);
// 	TIM4_ClearFlag(TIM4_FLAG_UPDATE);
//     if(nut == 1)
// 	{
// 		i++;
// 		if(i>5000)
// 		{
// 			i = 0;
// 			ketqua = dem;
// 			disableInterrupts();
// 			nut = 0;
// 		}	
// 	}
//  }  

// void nutnhan(void)
// {
// 	if(GPIO_ReadInputPin(GPIOD, GPIO_PIN_2)==0)
// 	{
// 		mydelay(20000);
// 		if(GPIO_ReadInputPin(GPIOD, GPIO_PIN_2)==0)
// 		{
// 			nut = 1;
// 			dem = 0;
// 			enableInterrupts();
// 			while(GPIO_ReadInputPin(GPIOD, GPIO_PIN_2)==0);
// 		}
// 	}
// }
/*-----------------OLED LCD SSD1306------------*/
void OLED_init(void)
{
	I2C_start();
	I2C_address(OLED_I2C_ADDR, OLED_CMD_MODE);
	for (uint8_t i = 0;i < 12;i++)
	{
		I2C_write(OLED_INIT_CMD[i]);
	}
	I2C_stop();
}
void OLED_printOneNumber(uint8_t num)
{
	uint16_t offset = num + 16;
	offset += offset << 2;
	I2C_start();
	I2C_address(OLED_I2C_ADDR, OLED_DAT_MODE);
	I2C_write(0x00);
	for(uint8_t i = 5; i;i--){ I2C_write(OLED_FONT[offset++]); }
	I2C_stop();
}
void OLED_printP(const char *p)
{
	I2C_start();
	I2C_address(OLED_I2C_ADDR, OLED_DAT_MODE);
	while (*p)
	{
		uint16_t offset = *p - 32;
		offset += offset << 2;
		I2C_write(0x00);
		for(uint8_t i = 5; i;i--){ I2C_write(OLED_FONT[offset++]); }
		p++;
	}
	I2C_stop();
}
void OLED_cursor(uint8_t xpos, uint8_t ypos)
{
	I2C_start();
	I2C_address(OLED_I2C_ADDR, OLED_CMD_MODE);
	I2C_write(xpos & 0x0F);
	I2C_write(0x10 | (xpos >> 4));
	I2C_write(0xB0 | (ypos & 0x07));
	I2C_stop();
}
void OLED_clear(void)
{
	OLED_cursor(0,0);
	I2C_start();
	I2C_address(OLED_I2C_ADDR, OLED_DAT_MODE);
	for (uint16_t i=0;i<512;i++)
	{
		I2C_write(0x00);
	}
	I2C_stop();
}